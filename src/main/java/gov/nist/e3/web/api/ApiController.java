package gov.nist.e3.web.api;

import gov.nist.e3.E3;
import gov.nist.e3.objects.input.Input;
import gov.nist.e3.objects.output.Output;
import gov.nist.e3.web.exceptions.ApiTokenException;
import gov.nist.e3.web.repository.ApiTokenRepository;
import gov.nist.e3.web.validation.ComplexValidation;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.async.DeferredResult;

import java.time.LocalDateTime;
import java.util.concurrent.ForkJoinPool;

/**
 * Spring controller that contains API endpoints.
 */
@RestController
@Validated
@RequestMapping("/api/v2")
public class ApiController {
    private static final Logger log = LoggerFactory.getLogger(ApiController.class);

    /**
     * Encoder for hashing and checking the API tokens. The BCrypt encoder is used which automatically salts encoded
     * strings.
     */
    private static final BCryptPasswordEncoder ENCODER = new BCryptPasswordEncoder();

    @Autowired
    ApiTokenRepository repository;

    /**
     * This is the main API resource of E3 that takes the JSON request and sends it to the calculation engine.
     * Takes the JSON input as a request body and the authorization header. Only a valid API token will be authorized
     * to use this endpoint.
     *
     * @param input         the E3 input obtained from the request POST body.
     * @param authorization the authorization header that must contain a valid API token in the format
     *                      "Api-Key prefix.token";
     * @return a deferred result that will return the output generated by the E3 engine.
     */
    @CrossOrigin
    @PostMapping("/analysis")
    public DeferredResult<Output> analysis(
            @ComplexValidation(withJsonSchema = "/e3-request-schema.json") Input input,
            @RequestHeader String authorization
    ) {
        // Check header format
        if (!authorization.startsWith("Api-Key: "))
            throw new ApiTokenException("API key header format is invalid");

        // Check UUID format
        String token;
        String prefix;
        try {
            var unparsed = authorization.replace("Api-Key: ", "");
            var split = unparsed.split("\\.");

            if (split.length < 2)
                throw new ApiTokenException("Token is not in format \"prefix.uuid\"");

            prefix = split[0];
            token = split[1];
        } catch (IllegalArgumentException e) {
            throw new ApiTokenException("API token not in correct format");
        }

        var apiToken = repository.getByPrefix(prefix);

        // Check if token exists in database
        if (apiToken == null)
            throw new ApiTokenException("API key is invalid");

        // Check if token matches hashed key
        if (!ENCODER.matches(token, apiToken.getToken()))
            throw new ApiTokenException("Prefix exists, but token is incorrect");

        // Check if token is expired
        @Nullable var expiry = apiToken.getExpiry();
        if (expiry != null && expiry.isBefore(LocalDateTime.now()))
            throw new ApiTokenException("API key is expired");

        // Check if token has been revoked
        if (apiToken.isRevoked())
            throw new ApiTokenException("API key has been revoked");

        // Pass input to E3 engine and return as deferred result
        var output = new DeferredResult<Output>();

        ForkJoinPool.commonPool().submit(() -> {
            try {
                var result = E3.analysis(input);
                output.setResult(result);
            } catch (Exception e) {
                e.printStackTrace();
                output.setErrorResult(e.getMessage());
            }
        });

        return output;
    }
}
